\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{array}

\usepackage{tikz}

\usepackage{biblatex} %Imports biblatex package
\addbibresource{ref.bib} %Import the bibliography file

\usepackage[linesnumbered]{algorithm2e}

\geometry{hmargin=4cm,vmargin=1.5cm}

\title{Internship Report}
\author{Solal Rapaport }
\date{June 2022}

\begin{document}

\maketitle

\section{Introduction}

The goal is to build formulas that will allow robots, spread on a ring, to gather. We have $k$ robots and we will use view vectors to build those formulas. The formulas will be an interpretation of the pseudo-code given in the research report \cite{gathering}.

The formulas we are building, will be used with formulas given in an other research report \cite{algo}, and then will be tested in the acceleration algorithm using an interpolant \cite{algo}

\section{Configuration with single multiplicity}

The strategy $\phi_{SM}$ is $true$ if the given configuration has a single multiplicity and that the robot calling the strategy should move toward the robot at distance $d_{0}$ :
\begin{center}
$\phi_{SM}(d_0, \ldots , d_{k-1}):=$\\
$(\bigvee_{i=0}^{k-1}(d_i = 0\bigwedge_{j=0\ j\not=i}^{k-1} (d_j > 0 \lor (d_j = 0 \land d_{j-1} = 0) ) ))\land$\\
$(d_{k-1} \not= 0) \land $\\
$((d_1 = 0 \land d_{k-2} = 0 \land d_0 \leq d_{k-1}) \lor (d_1 = 0 \land d_{k-2} \not= 0))$
\end{center}

In order to test our strategy we need a function that will initialize our first configuration and make it one with a single multiplicity without being already a winning one. Here is its implementation in python :

\begin{lstlisting}[language=Python]

def InitSM(p, s, t, taille_anneau):
    """
    Initialize the given configuration
    The configuration will have no multiplicity
    and won't be a winning one
    """
    tmpOr = []
    tmpAnd = []
    for i in range(len(p)):
        tmpOr.append(p[i] != p[(i+1)%len(p)])
    tmpAnd.append(Or(tmpOr))
    # we make sure there is no winning configuration
    # as a result of this function
    tmpOr = []
    for i in range(len(s)):
        tmpAnd.append(p[i] >= 0)
        tmpAnd.append(p[i] < taille_anneau)
        tmpAnd.append(s[i] == -1)
        tmpAnd.append(t[i] == 0)
    
    for i in range(len(p)):
        tmpAndbis = []
        tmpAndbis.append(p[i] == p[(i+1)%len(p)])
        tmpOrbis = []
        for j in range(len(p)):
            if((j != i) and (j != (i+1))):
                tmpOrbis.append(p[j] == p[i])
                tmpAndter=[]
                for h in range(len(p)):
                    if h !=j:
                        tmpAndter.append(p[h] != p[j])
                tmpOrbis.append(And(tmpAndter))
        tmpAndbis.append(Or(tmpOrbis))
        tmpOr.append(And(tmpAndbis))
    tmpAnd.append(Or(tmpOr))
    return And(tmpAnd)
\end{lstlisting}

We want to test this function, we choose a configuration with a ring of size 5 and 3 robots. We use the parameters below as an input :
\begin{lstlisting}[language=Python]

taille_anneau = 5       # Taille de l'anneau 
nb_robots = 3           # Nombre de robot sur l'anneau

p = [ Int('p%s' % i) for i in range(nb_robots) ]
s = [ Int('s%s' % i) for i in range(nb_robots) ]
t = [ Int('t%s' % i) for i in range(nb_robots) ]

tabInit = InitSM(p, s, t, taille_anneau)
print("tabInit :\n", tabInit)

solv1 = Solver()
solv1.add(tabInit)

print("solv1 : ",solv1.check())
if(solv1.check() == sat):
    print("model :\n",solv1.model())
\end{lstlisting}
The code above produces the following output : 
\begin{lstlisting}
tabInit :
 And(Or(p0 != p1, p1 != p2, p2 != p0),
    p0 >= 0,
    p0 < 5,
    s0 == -1,
    t0 == 0,
    p1 >= 0,
    p1 < 5,
    s1 == -1,
    t1 == 0,
    p2 >= 0,
    p2 < 5,
    s2 == -1,
    t2 == 0,
    Or(And(p0 == p1, Or(p2 == p0, And(p0 != p2, p1 != p2))),
       And(p1 == p2, Or(p0 == p1, And(p1 != p0, p2 != p0))),
       And(p2 == p0,
           Or(p0 == p2,
              And(p1 != p0, p2 != p0),
              p1 == p2,
              And(p0 != p1, p2 != p1)))))
solv1 :  sat
model :
 [p1 = 1,
 p0 = 0,
 p2 = 0,
 t2 = 0,
 s2 = -1,
 t1 = 0,
 s1 = -1,
 t0 = 0,
 s0 = -1]
\end{lstlisting}

What the model shows us is a configuration where robots 0 and 2 are in position 0 and robot 1 is in position 1.

Now we implement in python the $\phi_{SM}$ strategy :

\begin{lstlisting}[language=Python]

def phiSM(distances):
    tabAnd = []
    tabOr = []
    for i in range(len(distances)):
        tabAndBis = []
        tabAndBis.append(distances[i] == 0)
        for j in range(len(distances)):
            if j != i:
                tabOrBis.append(distances[j] > 0)
                tabOrBis.append(And(distances[j] == 0,
                    distances[j-1] == 0))
                tabAndBis.append(Or(tabOrBis))
        tabOr.append(And(tabAndBis))
    tabAnd.append(Or(tabOr))
    tabAnd.append(distances[-1] != 0)
    tabOr = []
    tabOr.append(And(distances[1] == 0, distances[-2] == 0,
        distances[0] <= distances[-1]))
    tabOr.append(And(distances[1] == 0, distances[-2] != 0))
    tabAnd.append(Or(tabOr))
    return And(tabAnd)
\end{lstlisting}

We test this function in the same configuration than given before with the following input :

\begin{lstlisting}[language=Python]

taille_anneau = 5       # Taille de l'anneau 
nb_robots = 3           # Nombre de robot sur l'anneau

p = [ Int('p%s' % i) for i in range(nb_robots) ]
s = [ Int('s%s' % i) for i in range(nb_robots) ]
t = [ Int('t%s' % i) for i in range(nb_robots) ]

d0 = [ Int('d%s' % i) for i in range(nb_robots) ]
d1 = [ Int('d%s' % i) for i in range(nb_robots) ]
d2 = [ Int('d%s' % i) for i in range(nb_robots) ]

tabInit = InitSM(p, s, t, taille_anneau)
tabConfig1 = ConfigView(taille_anneau, nb_robots, 0, p, d0)
tabConfig2 = ConfigView(taille_anneau, nb_robots, 1, p, d1)
tabConfig3 = ConfigView(taille_anneau, nb_robots, 2, p, d2)
tabPhiSM1 = phiSM(d0)
tabPhiSM2 = phiSM(d1)
tabPhiSM3 = phiSM(d2)

solv1 = Solver()
solv1.add(tabInit)
solv1.add(tabConfig1)
solv1.add(tabPhiSM1)

print("solv1 : ",solv1.check())
if(solv1.check() == sat):
        print("model :\n",solv1.model())

solv2 = Solver()
solv2.add(tabInit)
solv2.add(tabConfig2)
solv2.add(tabPhiSM2)

print("solv2 : ",solv2.check())
if(solv2.check() == sat):
        print("model :\n",solv2.model())

solv3 = Solver()
solv3.add(tabInit)
solv3.add(tabConfig3)
solv3.add(tabPhiSM3)

print("solv3 : ",solv3.check())
if(solv3.check() == sat):
        print("model :\n",solv3.model())
\end{lstlisting}

It produces the following output :

\begin{lstlisting}
solv1 :  sat
model :
 [d0 = 1,
 d2 = 4,
 p1 = 1,
 p0 = 0,
 p2 = 1,
 d1 = 0,
 t2 = 0,
 s2 = -1,
 t1 = 0,
 s1 = -1,
 t0 = 0,
 s0 = -1]
solv2 :  sat
model :
 [d0 = 1,
 d2 = 4,
 p1 = 0,
 p0 = 1,
 p2 = 1,
 d1 = 0,
 t2 = 0,
 s2 = -1,
 t1 = 0,
 s1 = -1,
 t0 = 0,
 s0 = -1]
solv3 :  sat
model :
 [d0 = 1,
 d2 = 4,
 p1 = 0,
 p0 = 0,
 p2 = 4,
 d1 = 0,
 t2 = 0,
 s2 = -1,
 t1 = 0,
 s1 = -1,
 t0 = 0,
 s0 = -1]
\end{lstlisting}

What it shows us is that every robot can move in this kind of configuration. The solver find a way to place the robot calling the strategy outside of the multiplicity and then allow the strategy to be true, meaning, the robot moves toward the multiplicity.

\section{Gathering rigid configurations}

Let $d_{ij}$ be the value $j$ of the view vector of the robot $i$, and $ds_{ij}$ the value $j$ of the symmetrical 
view of the robot $i$.
The robot is calling the strategy $\phi_R$, here are all the logic formulas used in order to build $\phi_R$:

$AllView$ is $true$ if $d_{00}, \ldots ,d_{k-1k-1}$ are all the views you can obtain from a single view vector $dist_{0}, \ldots ,dist_{k-1}$ :

\begin{center}
    
$AllView(dist_{0}, \ldots ,dist_{k-1}, d_{00}, \ldots ,d_{k-1k-1}):=$\\
$(\bigwedge_{i=0}^{k-1} (\bigwedge_{j=0}^{k-1} (d_{ij} = dist_{(j+i) \mod{k}}) ) )$
\end{center}

$IsRigid$ is $true$ if the given configuration is a rigid configuration. Meaning, all the views are distinct, and so there is no multiplicity, the configuration isn't symmetric or periodic.

\begin{center}

$IsRigid(d_{00}, \ldots ,d_{k-1k-1}, ds_{00}, \ldots ,ds_{k-1k-1}):=$\\
$\bigwedge_{i=0}^{k-1}(\bigwedge_{j=0}^{k-1}d_{ij}\not=0)\land $\\%pas de multiplicitÃ©
$\bigwedge_{i=0}^{k-1}(
\bigwedge_{l=0\ l\not=i}^{k-1}(
(\bigvee_{j=0}^{k-1}d_{ij} \not= d_{lj})
\land (\bigvee_{j=0}^{k-1}d_{ij} \not= ds_{lj})$\\
$\land (\bigvee_{j=0}^{k-1}ds_{ij} \not= d_{lj})
\land (\bigvee_{j=0}^{k-1}ds_{ij} \not= ds_{lj})
) )$\\%Toutes les vues sont distinctes
\end{center}

$AllCode$ is $true$ if $(\alpha'_{r}, \beta'_{r})$ is the set of two natural numbers of the robot $r$ such as $\alpha'_r$ and $\beta'_r$ are codes of $r$'s views, with $\alpha'_{r} < \beta'_{r}$. 

\begin{center}
$AllCode(d_{00}, \ldots ,d_{k-1k-1}, ds_{00}, \ldots ,ds_{k-1k-1}, \alpha_{0}, \dots, \alpha_{k-1}, \beta_{0}, \dots, \beta_{k-1},$\\
$\alpha'_{0}, \dots, \alpha'_{k-1}, \beta'_{0}, \dots, \beta'_{k-1}) :=$\\
$\bigwedge_{i = 0}^{k-1} \left( \alpha'_{i} < \beta'_{i} \land (\alpha'_{i} = \alpha_{i} \lor \alpha'_{i} = \beta_{i}) \land (\beta'_{i} = \alpha_{i} \lor \beta'_{i} = \beta_{i}) \right) \land $\\
$($
$(\alpha_{0} < \alpha_{1} < \dots < \alpha_{k-1} < \beta_{0} < \dots < \beta_{k-1}) \land $\\
$(\bigvee_{p=0}^{k-1}(\bigwedge_{q=0}^{p-1}(d_{0q} = d_{1q}) \land d_{0p} > d_{1p} ) )\land \dots \land $\\
$(\bigvee_{p=0}^{k-1}(\bigwedge_{q=0}^{p-1}(ds_{(k-2)q} = ds_{(k-1)q}) \land ds_{(k-2)p} > ds_{(k-1)p} ) )$\\
$\lor $\\
$((\alpha_{0} < \alpha_{2} < \alpha_{1} < \dots < \alpha_{k-1} < \beta_{0} < \dots < \beta_{k-1}) \land \dots) \lor \dots$
$)$
\end{center}

$CodeMaker$ is $true$ if the configuration is rigid and if $(a_{0}, \ldots , a_{k-1}, as_{0}, \ldots , as_{k-1})$ are each code of each view passed as a parameter :

\begin{center}
$CodeMaker(d_{00}, \ldots ,d_{k-1k-1}, ds_{00}, \ldots ,ds_{k-1k-1}, a_{0}, \ldots , a_{k-1}):=$\\
$IsRigid(d_{00}, \ldots ,d_{k-1k-1}, ds_{00}, \ldots ,ds_{k-1k-1}) \land $\\
%   le couple (alpha', beta') le premier ordre lexicographique, couple d'entier ordonnÃ©
%   alpha code vue, beta code de vue symÃ©trique
$\exists \alpha_{0}, \dots, \alpha_{k-1}, \beta_{0}, \dots, \beta_{k-1},$
$\alpha'_{0}, \dots, \alpha'_{k-1}, \beta'_{0}, \dots, \beta'_{k-1},$\\
$AllCode(d_{00}, \ldots ,d_{k-1k-1}, ds_{00}, \ldots ,ds_{k-1k-1}, \alpha_{0}, \dots, \alpha_{k-1}, \beta_{0}, \dots, \beta_{k-1}, $\\
$\alpha'_{0}, \dots, \alpha'_{k-1}, \beta'_{0}, \dots, \beta'_{k-1})$\\
$(\bigwedge_{i = 0}^{k-1} (\bigwedge_{j = 0, j\not=i}^{k-1} ((a_{i} > a_{j} \land \alpha'_{j} > \alpha'_{i}) \lor (a_{i} < a_{j} \land \alpha'_{j} < \alpha'_{i}) ) ) )$\\
$\bigwedge_{i=0}^{k-1} (\bigwedge_{j=0, j \not= i}^{k-1} a_{i} \not= a_{j})$
\end{center}

$FindMax$ is $true$ if $Max$ is the highest value of the view vector passed as a parameter :

\begin{center}

$FindMax(dist_{0}, \ldots ,dist_{k-1}, Max):=$\\
$(\bigwedge_{i=0}^{k-1} (Max \geq dist_{i}) \land (\bigvee_{i=0}^{k-1} (Max = dist_{i})))$
\end{center}

$FindM$ is $true$ if $M$ is the index of the robot (index in the view vector) which has the largest code of view and a neighboring robot at distance $Max$ :

\begin{center}

$FindM(d_{00}, \ldots ,d_{k-1k-1}, a_{0}, \ldots , a_{k-1}, Max, dM_{0}, \dots, dM_{k-1}):=$\\
$\bigvee_{m=0}^{k-1}((\bigwedge_{i=0}^{k-1} ((a_{m} \geq a_i \land (d_{i0} = Max \lor d_{ik-1} = Max))$\\
$\lor (d_{i0} < Max \land d_{ik-1} < Max))) \land M = m )$
\end{center}

$FindN$ is $true$ if $N$ is the index of the robot (index in the view vector) with the largest code of view and $M$ as a neighboring robot at distance $Max$ :

\begin{center}

$FindN(d_{00}, \ldots ,d_{k-1k-1}, a_{0}, \ldots , a_{k-1}, Max, M, N):=$\\
$(d_{M0} = Max \land d_{Mk-1} = Max \land $\\
$( (N = ((M+1) \mod{k}) \land a_{(M+1) \mod{k}} > a_{(M-1) \mod{k}}) \lor $\\
$(N = ((M-1) \mod{k}) \land a_{(M-1) \mod{k}} > a_{(M+1) \mod{k}})))$\\
$ \lor$\\
$(d_{M0} = Max \land d_{Mk-1} \not= Max \land N = ((M+1)\mod{k}))$\\
$ \lor$\\
$(d_{M0} \not= Max \land d_{Mk-1} = Max \land N = ((M-1)\mod{k}))$
\end{center}

Since those formulas can't be implemented in python because it is impossible to work around a variable index, we choose to build a new formula, $FindMN$ that will be $true$ if both vectors $dM$ and $dN$ are the view vector of, respectively, $M$ and $N$.

\begin{center}

$FindMN(d_{00}, \ldots ,d_{k-1k-1}, a_{0}, \ldots , a_{k-1}, Max, M, N,$\\
$ dM_{0}, \dots, dM_{k-1}, dN_{0}, \dots, dN_{k-1}):=$\\
$\bigvee_{m=0}^{k-1}(\quad
(\bigwedge_{i=0}^{k-1} ((a_{m} \geq a_i \land (d_{i0} = Max \lor d_{ik-1} = Max))$\\
$\lor (d_{i0} < Max \land d_{ik-1} < Max))) \land M = m \land $\\ 
%(\bigwedge_{l = 0}^{k-1} (dM_{l} = d_{ml}) )
%(\bigwedge_{l = 0}^{k - 1} (dN_{l} = d_{(m+1 \mod{k}) l}) )
%(\bigwedge_{l = 0}^{k - 1} (dN_{l} = d_{(m-1 \mod{k}) l}) )
$(\quad (
d_{m0} = Max \land d_{mk-1} = Max \land $\\
$( ( N = M+1 \mod k \land a_{(m+1) \mod{k}} > a_{(m-1) \mod{k}}) \lor $\\
$( N = M-1 \mod{k} \land a_{(m-1) \mod{k}} > a_{(m+1) \mod{k}}))
)\lor $\\
$(
d_{m0} = Max \land d_{mk-1} \not= Max \land N = M+1 \mod k
) \lor$\\
$(
d_{m0} \not= Max \land d_{mk-1} = Max \land N = M-1 \mod{k}
)\quad ) \land $\\
$( (N = M-1\mod{k} \land (\bigwedge_{l = 0}^{k-1} (dN_{l} = d_{(m-1 \mod{k}) ((k-1)-l)} \land dM_{l} = d_{ml}) ) ) \lor $\\
$(N = M+1\mod{k} \land (\bigwedge_{l = 0}^{k-1} (dN_{l} = d_{(m+1 \mod{k})l} \land dM_{l} = d_{m((k-1)-l)}) ) ) )$
$\quad )$
\end{center}

$\phi_R$ is $true$ if the robot can move toward a multiplicity. There must be only one multiplicity and the configuration must be rigid :

\begin{center}

$\phi_R(dist_{0}, \ldots ,dist_{k-1}):=$\\
$\exists d_{00}, \ldots ,d_{k-1k-1},\ AllView(dist_{0}, \ldots ,dist_{k-1}, d_{00}, \ldots ,d_{k-1k-1})\land$\\
$\exists ds_{00}, \ldots ,ds_{k-1k-1}, \bigwedge_{i=0}^{k-1} (ViewSym(d_{i0}, \ldots , d_{ik-1}, ds_{i0}, \ldots , ds_{ik-1}))\land$\\
$\exists Max, a_{0}, \ldots , a_{k-1}, dM_{0}, \dots, dM_{k-1}, dN_{0}, \dots, dN_{k-1},$\\
%on fait les codes de vues
$CodeMaker(d_{00}, \ldots ,d_{k-1k-1}, ds_{00}, \ldots ,ds_{k-1k-1}, a_{0}, \ldots , a_{k-1})\land$\\
%On initialise Max, M et N
$FindMax(dist_{0}, \ldots ,dist_{k-1}, Max) \land$\\
%Initialiser M et N
$FindMN(d_{00}, \ldots ,d_{k-1k-1}, a_{0}, \ldots , a_{k-1}, Max,  dM_{0}, \dots, dM_{k-1}, dN_{0}, \dots, dN_{k-1}) \land $\\
$\exists dM2_{0}, \dots, dM2_{k-1}, dN2_{0}, \dots, dN2_{k-1},$\\
$( (\bigwedge_{i = 0}^{k-1} (dM2_{i} = dM_{i+1 \mod{k}}) ) \lor (\bigwedge_{i = 0}^{k-1} (dM2_{i} = dM_{i-1 \mod{k}})) ) \land$\\
$(\bigvee_{i = 0}^{k-1} (dM2_{i} \not= dN_{i}) ) \land $\\
$( (\bigwedge_{i = 0}^{k-1} (dN2_{i} = dN_{i+1 \mod{k}}) ) \lor (\bigwedge_{i = 0}^{k-1} (dN2_{i} = dN_{i-1 \mod{k}})) ) \land$\\
$(\bigvee_{i = 0}^{k-1} (dN2_{i} \not= dM_{i}) ) \land $\\

%On initialise toutes les distances possibles par rapport Ã  M et N
$\exists distM_{0}, \ldots , distM_{k-1}, distN_{0}, \ldots , distN_{k-1},$\\
$\bigwedge_{i=0}^{k-1}(distM_{i} = (\sum_{l=0}^i dM_{l}) \land distN_{i} = (\sum_{l=0}^i dN_{l}) ) \land $\\
$(\bigvee_{i=0}^{k-1}\quad (\quad (distM_{i} < distN_{i} \bigwedge_{q=0}^{i} (distM_{q} = distN_{q}) \bigwedge_{j = 0}^{k-1} (dM_{j} = dist_{j}) ) \lor $\\
$(distM_{i} > distN_{i} \bigwedge_{q=0}^{i} (distM_{q} = distN_{q}) \bigwedge_{j = 0}^{k-1} (dN_{j} = dist_{j}) )\quad )\quad )$
\end{center}

\section{Gathering an odd number of robots}

We are now building a strategy, $\phi_{ON}$, that will gather an odd number of robots on a non-periodic configuration. It is the strategy with the lowest priority, it means that the configuration won't be rigid and won't have any multiplicity.

First we build the formula, $IsPeriodic$, that will return $true$ if the configuration is periodic with an odd number of robots :

\begin{center}
    
$IsPeriodic(dist_{0}, \ldots , dist_{k-1}):=$\\
$\exists p \in [1; \lfloor \frac{k}{3} \rfloor ], (p+1) \mod{2} = 0 \land $\\
$\exists d'_{0}, \ldots , d'_{p-1}, \bigwedge_{i=0}^{k-1} (d'_{i\mod{p}} = dist_{i})$
\end{center}

Now, we build build the $\phi_{OD}$ strategy, it returns $true$ if the configuration is non-rigid, non-periodic, has no multiplicity and has an odd number of robots. The robot just move in order to create a multiplicity or a rigid configuration that will lead to a rigid configuration or one with a multiplicity.

\begin{center}
    
$\phi_{ON}(dist_{0}, \ldots , dist_{k-1}):=$\\
$\exists d_{00}, \ldots ,d_{k-1k-1},\ AllView(dist_{0}, \ldots ,dist_{k-1}, d_{00}, \ldots ,d_{k-1k-1})\land$\\
$\exists ds_{00}, \ldots ,ds_{k-1k-1}, \bigwedge_{i=0}^{k-1} (ViewSym(d_{i0}, \ldots , d_{ik-1}, ds_{i0}, \ldots , ds_{ik-1}))\land$\\
$\lnot IsRigid(d_{00}, \ldots ,d_{k-1k-1}, ds_{00}, \ldots ,ds_{k-1k-1}) \land $\\
$((k+1) \mod{2} = 0) \land $\\
$\lnot IsPeriodic(dist_{0}, \ldots , dist_{k-1}) \land $\\
$(\bigwedge_{i=0}^{k-1} dist_{i} \not= 0) \land $\\
$(\bigwedge_{i=0}^{k-1} dist_{i} = ds_{0i})$
\end{center}

\section{Tests}

In order to test the algorithm \cite{algo} we will use the python code we show you at the beginning : $InitSM$ and $phiSM$.

We will use the SAT-solver to test different configurations. We will change the number of robots and the size of the ring from a test to an other.

\subsection{Test $InitSM$}

First, we test the function $InitSM$ alone : can we have an initial configuration with a single multiplicity with those parameters ?\\

\begin{tabular}{|r|c|c|c|c|c|}
  \hline
  nb-robot \textbackslash size-ring & 2 & 3 & 4 & 5 & 6\\
  \hline
  2 & Unsat & Unsat & Unsat & Unsat & Unsat \\
  \hline
  3 & Sat & Sat & Sat & Sat & Sat \\
  \hline
  4 & Sat & Sat & Sat & Sat & Sat \\
  \hline
  5 & Sat & Sat & Sat & Sat & Sat \\
  \hline
  6 & Sat & Sat & Sat & Sat & Sat \\
  \hline
\end{tabular}
\\

The results make sense : we can't create a multiplicity with 2 robots which is not a winning configuration. Else, even on a ring size of 2 we can have a multiplicity on one spot and only one robot on the other spot.

\subsection{Test $\phi_{SM}$}

Now we test $\phi_{SM}$ through the algorithm \cite{algo}, we also use the function $InitSM$ that makes sure we have a single multiplicity at the beginning.\\

\begin{tabular}{|r|c|c|c|c|c|}
  \hline
  nb-robot \textbackslash size-ring & 2 & 3 & 4 & 5 & 6\\
  \hline
  3 & Timeout & Timeout & Timeout & ... & ... \\
  \hline
  4 & Timeout & ... & ... & ... & ... \\
  \hline
  5 & ... & ... & ... & ... & ... \\
  \hline
  6 & ... & ... & ... & ... & ... \\
  \hline
\end{tabular}
\\

Same test but with the function $Init$ instead.\\

\begin{tabular}{|r|c|c|c|c|c|}
  \hline
  nb-robot \textbackslash size-ring & 2 & 3 & 4 & 5 & 6\\
  \hline
  3 & Timeout & Loose & Loose & Loose & ... \\
  \hline
  4 &  & ... & ... & ... & ... \\
  \hline
  5 & ... & ... & ... & ... & ... \\
  \hline
  6 & ... & ... & ... & ... & ... \\
  \hline
\end{tabular}

For $nb_{robot} = 3$ and $size_{ring} = 2$ we face this problem :
\begin{lstlisting}
Traceback (most recent call last):

  File "algov5.py", line 56, in <module>
  
    Ip = tree_interpolant(And(Interpolant(And(tmpAndInterpolant)), 
    And(tmpAndContext)))
    
  File "/usr/lib/python3.8/site-packages/z3/z3.py", line 8297, 
  in tree_interpolant
  
    res = Z3_compute_interpolant(ctx.ref(),f.as_ast(),p.params,ptr,mptr)
    
  File "/usr/lib/python3.8/site-packages/z3/z3core.py", line 4074, 
  in Z3_compute_interpolant
  
    _elems.Check(a0)
    
  File "/usr/lib/python3.8/site-packages/z3/z3core.py", line 1336, in Check
  
    raise self.Exception(self.get_error_message(ctx, err))
    
z3.z3types.Z3Exception: b'theory not supported by interpolation or bad proof'
\end{lstlisting}

\newpage

\SetKwComment{Comment}{/* }{ */}
\begin{algorithm}
\ForEach{synchronous winning strategy $f$}{
    $k = 1$\;
    \While{$true$}{
        $I(c) = Init(c)$\;
        $continue = true$\;
        \While{continue}{
            \If{$MaybeThisSize \not= null$}{
                $NotThisSizeBis = $[$i$ for $i$ in range($k$) and $i \notin elem$]\;
                \If{$Init(c) \land Post(c, c1), Post(c1, c2) \land \dots \land Post(c_{k-1}, c_{k}) \land BouclePerdante(c_{k}, NotThisSizeBis)\quad SAT$}{
                    $exit$\Comment*[r]{Loosing Strategy}
                }
            }
            \eIf{$I(c) \land Post(c, c1), Post(c1, c2) \land \dots \land Post(c_{k-1}, c_k) \land BouclePerdante(c_k, NotThisSize)\quad SAT$}{
                \eIf{$I = Init$}{
                    $exit$\Comment*[r]{Loosing Strategy}
                }{
                    $MaybeThisSize.append(k)$\;
                    $k = k + 1$\;
                    $continue = false$\;
                }
            }{
                $I' = Interpolant(I(c) \land Post(c, c1), Post(c1, c2) \land \dots \land Post(c_{k-1}, c_k) \land BouclePerdante(c_k, NotThisSize))$\;
                \eIf{$I' \implies I$}{
                    \eIf{$k = size_{max}$}{
                        $exit$\Comment*[r]{Winning Strategy}
                    }{
                        $NotThisSize.append(k)$\;
                        $k = k + 1$\;
                        $continue = false$\;
                    }
                }{
                    $I = I \lor I'$\;
                }
            }
        }
    }
}
\end{algorithm}

\printbibliography %Prints bibliography
\end{document}