\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{listings}

\geometry{hmargin=4cm,vmargin=1.5cm}

\title{Rapport de Stage}
\author{Solal Rapaport }
\date{June 2022}

\begin{document}

\maketitle

\section{Configuration with single multiplicity}

We have $k$ robots, robot $r$ is calling the strategy below :
\begin{center}
$phiSM(d_0, ..., d_{k-1}):=$\\
$(\lor_{i=0}^{k-1}(d_i = 0\land_{j=0\ j\not=i}^{k-1} d_j > 0))\land$\\
$(d_{k-1} \not= 0) \land $\\
$((d_1 = 0 \land d_{k-2} = 0 \land d_0 \leq d_{k-1}) \lor (d_1 = 0 \land d_{k-2} \not= 0))$
\end{center}

In order to test our strategy we need a function that will initialize our first configuration. Here is its implementation in python :

\begin{lstlisting}[language=Python]

def InitSM(p, s, t, taille_anneau):
    tmpOr = []
    tmpAnd = []
    for i in range(len(p) - 1):
        tmpOr.append(p[i] != p[i+1])
    tmpAnd.append(Or(tmpOr))
    # we make sure there is no winning configuration
    # as a result of this function
    tmpOr = []
    for i in range(len(s)):
        tmpAnd.append(p[i] >= 0)
        tmpAnd.append(p[i] < taille_anneau)
        tmpAnd.append(s[i] == -1)
        tmpAnd.append(t[i] == 0)
    
    for i in range(len(p)-1):
        tmpAndbis = []
        tmpAndbis.append(p[i] == p[i+1])
        tmpOrbis = []
        for j in range(len(p)):
            if((j != i) and (j != (i+1))):
                tmpOrbis.append(p[j] == p[i])
                tmpAndter=[]
                for h in range(len(p)):
                    if h !=j:
                        tmpAndter.append(p[h] != p[j])
                tmpOrbis.append(And(tmpAndter))
        tmpAndbis.append(Or(tmpOrbis))
        tmpOr.append(And(tmpAndbis))
    tmpAnd.append(Or(tmpOr))
    return And(tmpAnd)
\end{lstlisting}

We use the parameters below as an input :
\begin{lstlisting}[language=Python]

taille_anneau = 5       # Taille de l'anneau 
nb_robots = 3           # Nombre de robot sur l'anneau
s6 = Solver()

p = [ Int('p%s' % i) for i in range(nb_robots) ]
s = [ Int('s%s' % i) for i in range(nb_robots) ]
t = [ Int('t%s' % i) for i in range(nb_robots) ]

tabTest6 = InitSM(p, s, t, taille_anneau)
print("tabTest6 :\n", tabTest6)

s6.add(tabTest6)
print(s6.check())
if(s6.check() == sat):
    print("model :\n",s6.model())
\end{lstlisting}
The code above produces the following output : 
\begin{lstlisting}
tabTest6 :
 And(Or(p0 != p1, p1 != p2),
    p0 >= 0,
    p0 < 5,
    s0 == -1,
    t0 == 0,
    p1 >= 0,
    p1 < 5,
    s1 == -1,
    t1 == 0,
    p2 >= 0,
    p2 < 5,
    s2 == -1,
    t2 == 0,
    Or(And(p0 == p1, Or(p2 == p0, And(p0 != p2, p1 != p2))),
       And(p1 == p2, Or(p0 == p1, And(p1 != p0, p2 != p0)))))
sat
model :
 [p1 = 1,
 p0 = 0,
 p2 = 1,
 t2 = 0,
 s2 = -1,
 t1 = 0,
 s1 = -1,
 t0 = 0,
 s0 = -1]
\end{lstlisting}

Now we implement in python the $phiSM$ strategy : (code doesn't work right know, it needs to be fixed)

\begin{lstlisting}[language=Python]

def phiSM(distances):
    tabAnd = []
    tabOr = []
    for i in range(len(distances)):
        tabAndBis = []
        tabAndBis.append(distances[i] == 0)
        for j in range(len(distances)):
            if j != i:
                tabAndBis.append(distances[j] > 0)
        tabOr.append(And(tabAndBis))
    tabAnd.append(Or(tabOr))
    tabAnd.append(distances[-1] != 0)
    tabOr = []
    tabOr.append(And(distances[1] == 0, distances[-2] == 0,
        distances[0] <= distances[-1]))
    tabOr.append(And(distances[1] == 0, distances[-2] != 0))
    tabAnd.append(Or(tabOr))
    return And(tabAnd)
\end{lstlisting}

\section{Gathering rigid configurations}

%On a $k$ robots et donc $k$ valeurs par vecteur de vue, et le robot $r$ applique la stratégie suivante :
%\begin{center}
%$phiR(d_{00}, ...,d_{k-1k-1}):=$\\
%$\exists Max, M, N, ((a_{00}, a_{01}), ..., (a_{k0}, a_{k1}))$\\
%$(\land_{i=0}^{k-1}(\land_{j=0}^{k-1}d_{ij}\not=0))\land $\\
%$( \land_{i=0}^{k-1}($
%$\land_{l=0\ l\not=i}^{k-1}(
%(\lor_{j=0}^{k-1}d_{ij} \not= d_{lj})
%\land (\lor_{j=0}^{k}_{m=k-1}^{0}d_{ij} \not= d_{lm})
%\land (\lor_{j=0}^{k}_{m=k-1}^{0}d_{im} \not= d_{lj})
%\land (\lor_{j=0}^{k}_{m=k-1}^{0}d_{im} \not= d_{lm}) 
%) ))\land$\\
%on doit faire les codes de vues et élire une vue
%$()$
%\end{center}

Let $d_{ij}$ be the value $j$ of the view vector of the robot $i$, and $ds_{ij}$ the value $j$ of the symmetrical view of the
robot $i$.
The robot is calling the strategy below :

\begin{center}
$phiR(d_{00}, ...,d_{k-1k-1}):=$\\
$(\exists ds_{00}, ...,ds_{k-1k-1}, \land_{i=0}^{k-1} (ViewSym(d_{i0}, ..., d_{ik-1}, ds_{i0}, ..., ds_{ik-1})))\land$\\
$\exists Max, M, N, (a_{0}, ..., a_{k-1}, as_{0}, ..., as_{k-1}),$\\
$(\land_{i=0}^{k-1}(\land_{j=0}^{k-1}d_{ij}\not=0))\land $\\%pas de multiplicité
$( \land_{i=0}^{k-1}(
\land_{l=0\ l\not=i}^{k-1}(
(\lor_{j=0}^{k-1}d_{ij} \not= d_{lj})
\land (\lor_{j=0}^{k}d_{ij} \not= ds_{lj})$\\
$\land (\lor_{j=0}^{k}ds_{ij} \not= d_{lj})
\land (\lor_{j=0}^{k}ds_{ij} \not= ds_{lj})
) ))\land$\\%Toutes les vues sont distinctes
%on fait les codes de vues
$(\exists y_{0}, ..., y_{k-1},z \in [0;k-1], \forall x \in [0;k-1] \setminus [z], y\not=x \land
(\land_{h=y_{0}}^{y_{k-1}}(a_{x} > a_{h}) \land $\\
$(\lor_{p=0}^{k-1}(\land_{q=0}^{p-1}(d_{xq} = d_{yq}) \land d_{xp} > d_{yp} ) ) )\land $\\
$(a_{y} > a_{z} \land (\lor_{p=0}^{k-1}(\land_{q=0}^{p-1}(d_{yq} = d_{zq}) \land d_{yp} > d_{zp} ) ))
)\land$\\
%On initialise Max, M et N
$(\land_{j=0}^{k-1} (Max \geq d_{0j}) \land (\lor_{j=0}^{k-1} (Max = d_{0j})))\land$\\
%Initialiser M et N
%M
$(\exists r_1, r_1 \in [0; k-1], (d_{r_10} = Max \lor d_{r_1k-1} = Max) \land $\\
$((\land_{i=0}^{k-1} ((a_{r_1} \geq a_i \land a_{r_1} \geq as_i \land (d_{i0} = Max \lor d_{ik-1} = Max))$\\
$\lor (d_{i0} < Max \land d_{ik-1} < Max))) \lor$\\
$(\land_{i=0}^{k-1} ((as_{r_1} \geq a_i \land as_{r_1} \geq as_i \land (d_{i0} = Max \lor d_{ik-1} = Max))$\\
$\lor (d_{i0} < Max \land d_{ik-1} < Max)))) \land M = r_1) \land $\\
%N
%d' et d" sont les vecteurs de vues voisins à M, calculés en déplaçant les valeurs de 1 à droite ou à gauche
$(\exists (d'_{0}, ..., d'_{k-1}), (d"_{0}, ..., d"_{k-1}),$\\
%On trouve à quels vecteurs correspondent d' et d"
$(\land_{i=0}^{k-1} ((d'_{i} = d_{M((i+1)\mod{k})}) \land (d"_{i} = d_{M((i-1)\mod{k})}))) \land$\\
$\exists r_{\alpha}, r_{\beta} \in [0; k-1], \lor_{i=0}^{k-1}(((\land_{j=0}^{k-1}(d'_{j} = d_{ij})) \lor
(\land_{j=0}^{k-1}(d'_{j} = ds_{ij}) ))
\land r_{\alpha} = i )\land$\\
$(\lor_{i=0}^{k-1}(((\land_{j=0}^{k-1}(d"_{j} = d_{ij})) \lor
(\land_{j=0}^{k-1}(d"_{j} = ds_{ij}) ))
\land r_{\beta} = i )) ) \land$\\
%On intialise N en fonction du plus grand code de vue des voisins de M, le voisin doit aussi être à distance M
$((a_{r_\alpha} > as_{r_\alpha} \land a_{r_\alpha} > a_{r_\beta} \land a_{r_\alpha} > as_{r_\beta}
\land d_{r_{\alpha}k-1} = Max
\land N = r_{\alpha}) \lor$\\
$(a_{r_\beta} > as_{r_\beta} \land a_{r_\beta} > a_{r_\alpha} \land a_{r_\beta} > as_{r_\alpha} 
\land d_{r_{\beta}0} = Max
\land N = r_{\beta})
)$

\end{center}

\end{document}
